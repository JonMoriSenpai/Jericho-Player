<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Source: Handlers/Player.js</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <script src="scripts/nav.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/skyceil.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
</head>

<body>

<nav class="navbar">
    <h4><a href="index.html">Home</a></h4><h5 class="no-bottom must-underline">Classes</h5><ul><li><span class="small-icon C">C</span><b><a href="ClassUtils.html">ClassUtils</a></b><ul class="has-class-methods"><li><span class="small-icon F">F</span><a href="ClassUtils.html#.HumanTimeConversion">HumanTimeConversion</a></li><li><span class="small-icon F">F</span><a href="ClassUtils.html#.ScanDeps">ScanDeps</a></li><li><span class="small-icon F">F</span><a href="ClassUtils.html#.stablizingoptions">stablizingoptions</a></li></ul></li><li><span class="small-icon C">C</span><b><a href="Player.html">Player</a></b><ul class="has-class-methods"><li><span class="small-icon F">F</span><a href="Player.html#CreateQueue">CreateQueue</a></li><li><span class="small-icon F">F</span><a href="Player.html#DeleteQueue">DeleteQueue</a></li><li><span class="small-icon F">F</span><a href="Player.html#GetQueue">GetQueue</a></li><li><span class="small-icon M">M</span><a href="Player.html#Client">Client</a></li><li><span class="small-icon M">M</span><a href="Player.html#JerichoPlayerOptions">JerichoPlayerOptions</a></li></ul></li><li><span class="small-icon C">C</span><b><a href="Queue.html">Queue</a></b><ul class="has-class-methods"><li><span class="small-icon F">F</span><a href="Queue.html#autoplay">autoplay</a></li><li><span class="small-icon F">F</span><a href="Queue.html#back">back</a></li><li><span class="small-icon F">F</span><a href="Queue.html#clear">clear</a></li><li><span class="small-icon F">F</span><a href="Queue.html#createProgressBar">createProgressBar</a></li><li><span class="small-icon F">F</span><a href="Queue.html#destroy">destroy</a></li><li><span class="small-icon F">F</span><a href="Queue.html#insert">insert</a></li><li><span class="small-icon F">F</span><a href="Queue.html#loop">loop</a></li><li><span class="small-icon F">F</span><a href="Queue.html#mute">mute</a></li><li><span class="small-icon F">F</span><a href="Queue.html#pause">pause</a></li><li><span class="small-icon F">F</span><a href="Queue.html#play">play</a></li><li><span class="small-icon F">F</span><a href="Queue.html#remove">remove</a></li><li><span class="small-icon F">F</span><a href="Queue.html#repeat">repeat</a></li><li><span class="small-icon F">F</span><a href="Queue.html#resume">resume</a></li><li><span class="small-icon F">F</span><a href="Queue.html#search">search</a></li><li><span class="small-icon F">F</span><a href="Queue.html#skip">skip</a></li><li><span class="small-icon F">F</span><a href="Queue.html#stop">stop</a></li><li><span class="small-icon F">F</span><a href="Queue.html#unmute">unmute</a></li><li><span class="small-icon M">M</span><a href="Queue.html#Client">Client</a></li><li><span class="small-icon M">M</span><a href="Queue.html#current">current</a></li><li><span class="small-icon M">M</span><a href="Queue.html#currentTimestamp">currentTimestamp</a></li><li><span class="small-icon M">M</span><a href="Queue.html#destroyed">destroyed</a></li><li><span class="small-icon M">M</span><a href="Queue.html#guildId">guildId</a></li><li><span class="small-icon M">M</span><a href="Queue.html#message">message</a></li><li><span class="small-icon M">M</span><a href="Queue.html#metadata">metadata</a></li><li><span class="small-icon M">M</span><a href="Queue.html#MusicPlayer">MusicPlayer</a></li><li><span class="small-icon M">M</span><a href="Queue.html#paused">paused</a></li><li><span class="small-icon M">M</span><a href="Queue.html#Player">Player</a></li><li><span class="small-icon M">M</span><a href="Queue.html#playerMode">playerMode</a></li><li><span class="small-icon M">M</span><a href="Queue.html#playing">playing</a></li><li><span class="small-icon M">M</span><a href="Queue.html#previousTrack">previousTrack</a></li><li><span class="small-icon M">M</span><a href="Queue.html#QueueOptions">QueueOptions</a></li><li><span class="small-icon M">M</span><a href="Queue.html#StreamPacket">StreamPacket</a></li><li><span class="small-icon M">M</span><a href="Queue.html#tracks">tracks</a></li><li><span class="small-icon M">M</span><a href="Queue.html#volume">volume</a></li></ul></li><li><span class="small-icon C">C</span><b><a href="VoiceUtils.html">VoiceUtils</a></b><ul class="has-class-methods"><li><span class="small-icon F">F</span><a href="VoiceUtils.html#.disconnect">disconnect</a></li><li><span class="small-icon F">F</span><a href="VoiceUtils.html#.join">join</a></li></ul></li></ul><h4><a href="global.html">Global</a></h4>
</nav>

<div id="main">
    <div class="burger">
        <div class="burger-line-1"></div>
        <div class="burger-line-2"></div>
        <div class="burger-line-3"></div>
    </div>

    <h1 class="page-title">Source: Handlers/Player.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const EventEmitter = require('events');
const { FFmpeg } = require('prism-media');
const {
  Intents,
  Client,
  Message,
  Interaction,
  VoiceChannel,
  StageChannel,
} = require('discord.js');
const Queue = require('./Queue.js');
const ClassUtils = require('../Utilities/ClassUtils');
const { join } = require('../Utilities/VoiceUtils');
const {
  DefaultJerichoPlayerOptions,
  DefaultQueueCreateOptions,
} = require('../types/interfaces');

/**
 * Jericho Player's Player Class
 * @extends {EventEmitter}
 */

class Player extends EventEmitter {
  /**
   * QueueCaches -> Caches of Queues for per "instanceof Player"
   * @type {Object}
   * @readonly
   * @private
   */
  static #QueueCaches = {};

  /**
   * Jericho Player Constructor
   * @param {Client} Client  Instanceof Discord.js Client
   * @param {DefaultJerichoPlayerOptions} JerichoPlayerOptions [options={}] Player Options for Stream Extraction and Voice Connection Moderation
   */

  constructor(
    Client,
    JerichoPlayerOptions = {
      extractor: 'play-dl',
      ExtractorStreamOptions: {
        Limit: 1,
        Quality: 'high',
        Cookies: undefined,
        ByPassYoutubeDLRatelimit: true,
        YoutubeDLCookiesFilePath: undefined,
        Proxy: undefined,
      },
      IgnoreError: true,
      LeaveOnEmpty: true,
      LeaveOnEnd: true,
      LeaveOnBotOnly: true,
      LeaveOnEmptyTimedout: 0,
      LeaveOnEndTimedout: 0,
      LeaveOnBotOnlyTimedout: 0,
    },
  ) {
    super();

    this.#__buildsandDepschecks(Client);

    /**
     * Client Discord Client Instance
     * @type {Client}
     * @readonly
     */
    this.Client = Client;

    /**
     * Jericho Player Default Options Saved for Class Utils Comparing and Fixing
     * @type {DefaultJerichoPlayerOptions}
     * @readonly
     */

    this.JerichoPlayerOptions = ClassUtils.stablizingoptions(
      JerichoPlayerOptions,
      DefaultJerichoPlayerOptions,
    );

    /**
     * - Voice Events will be Moderated from here Except "LeaveonEnd" Object Value it's Timedout Value
     * - Node js Timeout Id's as Number will be Cached for Clear Timeout here and in "Queue.#__QueueAudioPlayerStatusManager()"
     */

    this.Client.on('voiceStateUpdate', async (OldVoiceState, NewVoiceState) => {
      /*
       * - QueueInstance Fetched from Private Raw Cache Fetching Method "Player.#QueueCacheFetch(guildId)"
       * - QueueIntance => will be used to filter Voice Events Related to our Queue or else return undefined for handling
       */

      const QueueInstance = Player.#QueueCacheFetch(
        (NewVoiceState ? NewVoiceState.guild.id : undefined)
          ?? (OldVoiceState ? OldVoiceState.guild.id : undefined),
      );

      const clientchecks = (member) => member.user.id === this.Client.user.id;

      // - QueueInstance checking if its related to Queue Voice Connection Events

      if (!NewVoiceState.channel &amp;&amp; OldVoiceState.id === this.Client.user.id) {
        /**
         * - event "channelEmpty" and "botDisconnect" will trigger on bot leaving the VC | Timeout will be Handlerd in - "Queue.#__ResourcePlay()"
         * - events are in order to provide quick response with a minimal checks
         */
        if (
          OldVoiceState.channel
          &amp;&amp; OldVoiceState.channel.members
          &amp;&amp; ((OldVoiceState.channel.members.size === 1
            &amp;&amp; OldVoiceState.channel.members.some(clientchecks))
            || OldVoiceState.channel.members.size === 0)
        ) {
          this.emit('channelEmpty', QueueInstance, OldVoiceState.channel);
        }
        this.emit(
          'botDisconnect',
          QueueInstance,
          OldVoiceState.channel ?? undefined,
        );
        return this.DeleteQueue(QueueInstance.guildId);
      }
      if (
        !QueueInstance
        || (QueueInstance &amp;&amp; QueueInstance.destroyed)
        || (QueueInstance &amp;&amp; !QueueInstance.playing)
        || (NewVoiceState.channel
          &amp;&amp; OldVoiceState.channel
          &amp;&amp; OldVoiceState.channel.id === NewVoiceState.channel.id)
        || !(
          (NewVoiceState.channel
            &amp;&amp; QueueInstance.StreamPacket
            &amp;&amp; QueueInstance.StreamPacket.VoiceChannel
            &amp;&amp; QueueInstance.StreamPacket.VoiceChannel.id
              === NewVoiceState.channel.id)
          || (OldVoiceState.channel
            &amp;&amp; QueueInstance.StreamPacket
            &amp;&amp; QueueInstance.StreamPacket.VoiceChannel
            &amp;&amp; QueueInstance.StreamPacket.VoiceChannel.id
              === OldVoiceState.channel.id)
        )
      ) {
        return void null;
      }
      if (
        OldVoiceState.channel
        &amp;&amp; NewVoiceState.channel
        &amp;&amp; OldVoiceState.channel.id !== NewVoiceState.channel.id
        &amp;&amp; NewVoiceState.id === this.Client.user.id
      ) {
        /**
         * - QueueInstance.StreamPacket.VoiceConnection &amp;&amp; QueueInstance.StreamPacket.VoiceChannel changed based on Client has been Moved to Different Channel
         * - Queue Voice Connection and Channel will be Changed with Resource Subscription will be Changed from the function "this.#__handleVoiceConnectionInterchange()"
         * - QueueInstance with new Refrence Value will be Cached to Player's Queue Caches
         */

        await this.#__handleVoiceConnectionInterchange(
          Player.#QueueCaches[NewVoiceState.guild.id],
          NewVoiceState.channel,
        );

        /**
         * - QueueInstance will check for "LeaveOnEmpty" &amp;&amp; "LeaveOnBotOnly" state to filter the @discordjs/voice's Player's playing status for the Queue
         * - Function will return undefined and can take time depends on setTimeout value of if 0 or undefined
         */

        return this.#__playerVoiceConnectionMainHandler(
          Player.#QueueCaches[NewVoiceState.guild.id],
          NewVoiceState.channel,
        );
      }
      if (
        (!NewVoiceState.channel &amp;&amp; OldVoiceState.id !== this.Client.user.id)
        || (NewVoiceState.channel
          &amp;&amp; QueueInstance.StreamPacket
          &amp;&amp; QueueInstance.StreamPacket.VoiceChannel
          &amp;&amp; QueueInstance.StreamPacket.VoiceChannel.id
            === NewVoiceState.channel.id
          &amp;&amp; NewVoiceState.id !== this.Client.user.id)
      ) {
        /**
         * - QueueInstance will check for "LeaveOnEmpty" &amp;&amp; "LeaveOnBotOnly" state to filter the @discordjs/voice's Player's playing status for the Queue
         * - Function will return undefined and can take time depends on setTimeout value of if 0 or undefined
         * - On leave of Users from Voice Channel Player will check stricitly
         */

        return this.#__playerVoiceConnectionMainHandler(
          Player.#QueueCaches[OldVoiceState.guild.id],
          NewVoiceState.channel ?? OldVoiceState.channel,
        );
      }
      return void null;
    });
  }

  /**
   * CreateQueue => Create Queue Instance for Player and per Guild
   * @param {Message | Interaction} message Guild Message Only for getting info about guild and guildId
   * @param {DefaultQueueCreateOptions|void} QueueCreateOptions => Queue Create Options for Queue Instance ( for making ByDefault Values for Queue.&lt;methods> )
   * @returns {Queue} Queue Instance => ( for Queue.&lt;methods> like Queue.play() )
   */

  CreateQueue(
    message,
    QueueCreateOptions = {
      extractor: undefined,
      metadata: null,
      ExtractorStreamOptions: {
        Limit: undefined,
        Quality: undefined,
        Cookies: undefined,
        ByPassYoutubeDLRatelimit: true,
        YoutubeDLCookiesFilePath: undefined,
        Proxy: undefined,
      },
      IgnoreError: undefined,
      LeaveOnEmpty: undefined,
      LeaveOnEnd: undefined,
      LeaveOnBotOnly: undefined,
      LeaveOnEmptyTimedout: undefined,
      LeaveOnEndTimedout: undefined,
      LeaveOnBotOnlyTimedout: undefined,
    },
  ) {
    // this.#__buildsandDepschecks() -> Checks for Invalid Client , Missing Dependencies with Missing Discord Client Voice Intents

    this.#__buildsandDepschecks(this.Client);
    if (
      !message
      || !(
        message
        &amp;&amp; message.guild
        &amp;&amp; message.guild.id
        &amp;&amp; message.channel
        &amp;&amp; message.channel.id
      )
    ) {
      // Throw Error in Player Events as "error" event for Invalid Guild's Message

      return void this.emit('error', 'Invalid Guild Message', this, message);
    }

    // Picking up valid and user defined options if any and comparing them with Player Default Options

    QueueCreateOptions = ClassUtils.stablizingoptions(
      QueueCreateOptions,
      this.JerichoPlayerOptions,
    );

    // To Avoid excess use of memory and Space in Large bots , We will always Cache Queue and Create one if is Deleted by DeleteQueue() method
    const QueueInstance = Player.#QueueCacheFetch(message.guild.id, QueueCreateOptions)
      ?? new Queue(this.Client, message, QueueCreateOptions, this);
    return Player.#QueueCacheAdd(QueueInstance);
  }

  /**
   * DeleteQueue -> Delete's Cached Queue (forced way to erase Queue's Existence)
   * @param {String|Number} guildId Guild["id"] OR guild.id is required to fetch queue from the Cache
   * @returns {void} Returns "undefined"
   */

  DeleteQueue(guildId) {
    if (
      !guildId
      || !(guildId &amp;&amp; (typeof guildId === 'string' || typeof guildId === 'number'))
    ) {
      return void this.emit('error', 'Invalid Guild Id', this, guildId);
    }
    // Checks for Queue in Cache doesn't matter if its Connection was destroyed | Cache only fetch its Existence to avoid excess CPU load
    if (Player.#QueueCacheFetch(guildId)) {
      return void Player.#QueueCacheRemove(guildId);
    }
    return void this.emit('error', 'Destroyed Queue', undefined);
  }

  /**
   * GetQueue -> Fetch Queue (Instance) from Cache or else returns undefined
   * @param {String|Number} guildId Guild["id"] OR guild.id is required to fetch queue from the Cache
   * @returns {Queue|void} Returns Queue Instance or else "undefined"
   */
  GetQueue(guildId) {
    if (
      !guildId
      || !(guildId &amp;&amp; (typeof guildId === 'string' || typeof guildId === 'number'))
    ) {
      return void this.emit('error', 'Invalid Guild Id', this, guildId);
    }
    return Player.#QueueCacheFetch(guildId);
  }

  /**
   * @private Player Class Defined Method
   * #QueueCacheAdd -> Private Method for Player's Workload to Add Queue Cache Easily without using any Player's Instance
   * @param {Queue} QueueInstance Queue Instance made from "Queue" class to work around with many &lt;Queue>.methods() for a guild
   * @returns {Queue} QueueInstance , To reperesnt the Work Complete Signal
   */

  static #QueueCacheAdd(QueueInstance) {
    Player.#QueueCaches[`${QueueInstance.guildId}`] = QueueInstance;
    return QueueInstance;
  }

  /**
   * @private Player Class Defined Method
   * #QueueCacheFetch -> Private Method for Player's Workload to Fetch Queue Cache Easily without using any Player's Instance
   * @param {String|Number} guildId Guild["id"] OR guild.id is required to fetch queue from the Cache
   * @param {DefaultQueueCreateOptions} QueueCreateOptions QueueCreateOptions for if Queue "connection" is destroyed , then it requires Options to remake whole infrastructure
   * @returns {Queue|void} QueueInstance , To reperesnt the Work Complete Signal
   */

  static #QueueCacheFetch(guildId, QueueCreateOptions = null) {
    const QueueInstance = Player.#QueueCaches[`${guildId}`];
    if (QueueCreateOptions &amp;&amp; QueueInstance) {
      QueueInstance.QueueOptions = ClassUtils.stablizingoptions(
        QueueCreateOptions,
        QueueInstance.QueueOptions,
      );
      if (QueueInstance &amp;&amp; QueueInstance.destroyed &amp;&amp; typeof QueueInstance.destroyed !== 'boolean') clearTimeout(QueueInstance.destroyed);
      QueueInstance.destroyed = false;
      Player.#QueueCaches[`${guildId}`] = QueueInstance;
    }
    return Player.#QueueCaches[`${guildId}`];
  }

  /**
   * Player Class Defined Method
   * #QueueCacheRemove -> Private Method for Player's Workload to Remove Queue Cache Easily without using any Player's Instance
   * @param {String|Number} guildId Guild["id"] OR guild.id is required to fetch queue from the Cache
   * @returns {void} undefined , To reperesnt the Work Complete Signal as Queue will be destroyed so , we can't return Queue
   * @private
   */

  static #QueueCacheRemove(guildId) {
    if (!this.#QueueCacheFetch(guildId)) return false;
    let QueueInstance = Player.#QueueCaches[`${guildId}`];
    if (Player.#QueueCaches[`${guildId}`].playing) {
      Player.#QueueCaches[`${guildId}`].stop();
    }
    if (!QueueInstance.destroyed) QueueInstance.destroy();
    const Garbage = {};
    Garbage.Structure = QueueInstance;
    QueueInstance = null;
    Player.#QueueCaches[`${guildId}`] = null;
    delete Garbage.Structure;
    return void null;
  }

  /**
   * Player Class Defined Method
   * #__playerVoiceConnectionMainHandler -> Private Method for Player's Voice Connection "Manager" to Filter out Connection Decisions frpm Queue | Player 's Connection Options from User
   * @param {Queue} QueueInstance Queue Instance made from "Queue" class to work around
   * @param {VoiceChannel|StageChannel} VoiceChannel Simple Discord Voice Channel | Stage Channel Value
   * @returns {void} undefined, As these Private method only meant for Voice Handling with Options
   * @private
   */
  #__playerVoiceConnectionMainHandler(QueueInstance, VoiceChannel) {
    const clientchecks = (member) => member.user.id === this.Client.user.id;
    const userchecks = (member) => !member.user.bot;

    if (
      QueueInstance.QueueOptions.LeaveOnEmpty
      &amp;&amp; ((VoiceChannel.members.size === 1
        &amp;&amp; VoiceChannel.members.some(clientchecks))
        || VoiceChannel.members.size === 0)
    ) {
      QueueInstance.StreamPacket.TimedoutId
        ? clearTimeout(Number(QueueInstance.StreamPacket.TimedoutId))
        : undefined;
      QueueInstance.StreamPacket.TimedoutId = QueueInstance.destroy(
        QueueInstance.QueueOptions.LeaveOnBotOnlyTimedout ?? 0,
      ) ?? undefined;
    }
    if (
      (QueueInstance.QueueOptions.LeaveOnBotOnly
        &amp;&amp; !VoiceChannel.members.some(userchecks)
        &amp;&amp; VoiceChannel.members.some(clientchecks)
        &amp;&amp; VoiceChannel.members.size > 1)
      || (!VoiceChannel.members.some(userchecks)
        &amp;&amp; !VoiceChannel.members.some(clientchecks)
        &amp;&amp; VoiceChannel.members.size &lt;= 1)
    ) {
      QueueInstance.StreamPacket.TimedoutId
        ? clearTimeout(Number(QueueInstance.StreamPacket.TimedoutId))
        : undefined;
      QueueInstance.StreamPacket.TimedoutId = QueueInstance.destroy(
        QueueInstance.QueueOptions.LeaveOnBotOnlyTimedout ?? 0,
      ) ?? undefined;
    }
    return void null;
  }

  /**
   * Player Class Defined Method
   * #__handleVoiceConnectionInterchange -> Private Method for Player's Voice Destroy Connection
   * @param {Queue} QueueInstance Queue Instance made from "Queue" class to work around
   * @param {VoiceChannel|StageChannel} VoiceChannel Simple Discord Voice Channel | Stage Channel Value
   * @returns {Promise&lt;void>} undefined, As these Private method only meant for Voice Handling with Options
   * @private
   */

  async #__handleVoiceConnectionInterchange(QueueInstance, VoiceChannel) {
    QueueInstance.StreamPacket.VoiceConnection = await join(
      this.Client,
      VoiceChannel,
    );
    QueueInstance.StreamPacket.VoiceChannel = VoiceChannel;
    if (
      QueueInstance.playing
      &amp;&amp; !QueueInstance.paused
      &amp;&amp; QueueInstance.StreamPacket.subscription
    ) {
      QueueInstance.StreamPacket.subscription.unsubscribe();
      QueueInstance.StreamPacket.subscription = QueueInstance.StreamPacket.VoiceConnection.subscribe(
        QueueInstance.MusicPlayer,
      );
    }
    Player.#QueueCaches[QueueInstance.guildId] = QueueInstance;
    return void null;
  }

  /**
   * Player Class Defined Method
   * #__buildsandDepschecks -> Private Method for Checks for Dependencies , Intents to avoid Internal value errors or package bugs
   * @param {Client} Client Discord Client Instance for Operating as a Bot
   * @returns {void} undefined, As these Private method only meant for Voice Handling with Options
   * @private
   */

  #__buildsandDepschecks(Client) {
    let FmpeggGarbage;
    let LibopusGarbage;
    const MissingDeps = [' '];
    MissingDeps.push(
      '--[ Missing Dependencies from package.json | Do - "npm i packageName" ]--',
    );
    try {
      const GarbageInfo = FFmpeg.getInfo();
      FmpeggGarbage = !!`- version: ${GarbageInfo.version}`;
      LibopusGarbage = !!`- libopus: ${
        GarbageInfo.output.includes('--enable-libopus') ? 'yes' : 'no'
      }`;
    } catch (err) {
      LibopusGarbage = FmpeggGarbage = undefined;
    }
    !ClassUtils.ScanDeps('@discordjs/voice')
      ? MissingDeps.push(`${MissingDeps.length - 1})  "@discordjs/voice"`)
      : undefined;
    !ClassUtils.ScanDeps('prism-media')
      ? MissingDeps.push(`${MissingDeps.length - 1})  "prism-media"`)
      : undefined;

    !ClassUtils.ScanDeps('@discordjs/opus')
    &amp;&amp; !ClassUtils.ScanDeps('opusscript')
      ? MissingDeps.push(
        `${MissingDeps.length - 1})  "@discordjs/opus" OR "opusscript"`,
      )
      : undefined;

    !ClassUtils.ScanDeps('tweetnacl')
    &amp;&amp; !(ClassUtils.ScanDeps('libsodium-wrapper') &amp;&amp; ClassUtils.ScanDeps('sodium'))
      ? MissingDeps.push(
        `${
          MissingDeps.length - 1
        })  "tweetnacl" OR ("libsodium-wrapper" And "sodium")`,
      )
      : undefined;

    !ClassUtils.ScanDeps('ffmpeg-static') &amp;&amp; !(LibopusGarbage &amp;&amp; FmpeggGarbage)
      ? MissingDeps.push(
        `${
          MissingDeps.length - 1
        })  "ffmpeg-static" OR "Ffmpeg from [https://www.ffmpeg.org/download.html]"`,
      )
      : undefined;

    !ClassUtils.ScanDeps('playdl-music-extractor')
    &amp;&amp; !ClassUtils.ScanDeps('video-extractor')
      ? MissingDeps.push(
        `${
          MissingDeps.length - 1
        })  "playdl-music-extractor" OR "video-extractor"`,
      )
      : undefined;
    if (MissingDeps[2]) {
      setTimeout(() => {
        this.emit(
          'error',
          [
            '-'.repeat(50),
            ...MissingDeps,
            '--[ queue value will be undefined By-default as it will trigger as ->  player.on("error",errorMessage) => {} ]--',
            '-'.repeat(50),
          ].join('\n'),
        );
      }, 2 * 1000);
    }
    if (!Client) {
      throw Error(
        'Invalid Discord Client has been Detected! | And get some Voice and Channel Intents too',
      );
    } else if (
      !new Intents(Client.options.intents).has(
        Intents.FLAGS.GUILD_VOICE_STATES,
      )
      &amp;&amp; !new Intents(Client.options.intents).has(Intents.FLAGS.GUILDS)
    ) {
      throw SyntaxError(
        'Missing Intents in Discord Client\n - GUILD_VOICE_STATES || Intents.FLAGS.GUILD_VOICE_STATES\n - - GUILDS || Intents.FLAGS.GUILDS',
      );
    } else if (
      !new Intents(Client.options.intents).has(Intents.FLAGS.GUILD_VOICE_STATES)
    ) {
      throw SyntaxError(
        'Missing Intents in Discord Client\n - GUILD_VOICE_STATES || Intents.FLAGS.GUILD_VOICE_STATES',
      );
    } else if (!new Intents(Client.options.intents).has(Intents.FLAGS.GUILDS)) {
      throw SyntaxError(
        'Missing Intents in Discord Client\n - GUILDS || Intents.FLAGS.GUILDS',
      );
    } else return void null;
  }
}

module.exports = Player;
</code></pre>
        </article>
    </section>





</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.4</a> on Tue Nov 09 2021 14:44:16 GMT+0000 (Coordinated Universal Time) using <a href="https://github.com/zyrouge/jsdoc-skyceil">Skyceil Theme</a>
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>

</body>
</html>
