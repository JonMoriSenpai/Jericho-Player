<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Source: gen/packets.js</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <script src="scripts/nav.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/skyceil.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
</head>

<body>

<nav class="navbar">
    <h4><a href="index.html">Home</a></h4><h5 class="no-bottom must-underline">Classes</h5><ul><li><span class="small-icon C">C</span><b><a href="downloader.html">downloader</a></b><ul class="has-class-methods"><li><span class="small-icon M">M</span><a href="downloader.html#eventEmitter">eventEmitter</a></li><li><span class="small-icon M">M</span><a href="downloader.html#options">options</a></li><li><span class="small-icon M">M</span><a href="downloader.html#packet">packet</a></li><li><span class="small-icon M">M</span><a href="downloader.html#playdl">playdl</a></li><li><span class="small-icon M">M</span><a href="downloader.html#player">player</a></li><li><span class="small-icon M">M</span><a href="downloader.html#queue">queue</a></li></ul></li><li><span class="small-icon C">C</span><b><a href="packets.html">packets</a></b><ul class="has-class-methods"><li><span class="small-icon M">M</span><a href="packets.html#__privateCaches">__privateCaches</a></li><li><span class="small-icon M">M</span><a href="packets.html#audioPlayer">audioPlayer</a></li><li><span class="small-icon M">M</span><a href="packets.html#destroyed">destroyed</a></li><li><span class="small-icon M">M</span><a href="packets.html#downloader">downloader</a></li><li><span class="small-icon M">M</span><a href="packets.html#eventEmitter">eventEmitter</a></li><li><span class="small-icon M">M</span><a href="packets.html#guildId">guildId</a></li><li><span class="small-icon M">M</span><a href="packets.html#options">options</a></li><li><span class="small-icon M">M</span><a href="packets.html#player">player</a></li><li><span class="small-icon M">M</span><a href="packets.html#queue">queue</a></li><li><span class="small-icon M">M</span><a href="packets.html#tracksMetadata">tracksMetadata</a></li><li><span class="small-icon M">M</span><a href="packets.html#type">type</a></li><li><span class="small-icon M">M</span><a href="packets.html#voiceMod">voiceMod</a></li></ul></li><li><span class="small-icon C">C</span><a href="player%2520-_%2520Player%2520Class%2520for%2520Discord%2520Client%2520v14%2520for%2520Jericho-Player%2520Framework.html">player -> Player Class for Discord Client v14 for Jericho-Player Framework</a></li><li><span class="small-icon C">C</span><b><a href="queue.html">queue</a></b><ul class="has-class-methods"><li><span class="small-icon F">F</span><a href="queue.html#clear">clear</a></li><li><span class="small-icon M">M</span><a href="queue.html#current">current</a></li><li><span class="small-icon M">M</span><a href="queue.html#destroyed">destroyed</a></li><li><span class="small-icon M">M</span><a href="queue.html#discordClient">discordClient</a></li><li><span class="small-icon M">M</span><a href="queue.html#eventEmitter">eventEmitter</a></li><li><span class="small-icon M">M</span><a href="queue.html#guildId">guildId</a></li><li><span class="small-icon M">M</span><a href="queue.html#options">options</a></li><li><span class="small-icon M">M</span><a href="queue.html#packet">packet</a></li><li><span class="small-icon M">M</span><a href="queue.html#paused">paused</a></li><li><span class="small-icon M">M</span><a href="queue.html#player">player</a></li><li><span class="small-icon M">M</span><a href="queue.html#playing">playing</a></li><li><span class="small-icon M">M</span><a href="queue.html#previousTrack">previousTrack</a></li><li><span class="small-icon M">M</span><a href="queue.html#previousTracks">previousTracks</a></li><li><span class="small-icon M">M</span><a href="queue.html#tracks">tracks</a></li><li><span class="small-icon M">M</span><a href="queue.html#voiceConnection">voiceConnection</a></li><li><span class="small-icon M">M</span><a href="queue.html#voiceMod">voiceMod</a></li><li><span class="small-icon M">M</span><a href="queue.html#volume">volume</a></li><li><span class="small-icon M">M</span><a href="queue.html#working">working</a></li></ul></li><li><span class="small-icon C">C</span><a href="voiceMod.html">voiceMod</a></li></ul><h4>Global</h4><ul><li><a href="global.html#__cacheAndCleanTracksCacheandCleanTracksonTrackEndeventTrigger/Requirement">__cacheAndCleanTracks Cache and Clean Tracks on Track End event Trigger/Requirement</a></li><li><a href="global.html#__perfectCleanPerfectcleanforavoidingMemoryleakandreleasethetidewithRAMusuage">__perfectClean Perfect clean for avoiding Memory leak and release the tide with RAM usuage</a></li><li><a href="global.html#__playlistModPlaylistModeratorforeventsandparsingrawPlaylist/AlbumData">__playlistMod Playlist Moderator for events and parsing raw Playlist/Album Data</a></li><li><a href="global.html#__queryFilterQueryFilterfortheSongUrlschecks">__queryFilter Query Filter for the Song Urls checks</a></li><li><a href="global.html#__trackMovementManagerTrackMovementAudioResourceandFetchingProperly">__trackMovementManager Track Movement Audio Resource and Fetching Properly</a></li><li><a href="global.html#__tracksModTracksModeratorforeventsandparsingrawTracksDatafromdefaultextractors">__tracksMod Tracks Moderator for events and parsing raw Tracks Data from default extractors</a></li><li><a href="global.html#backBackMethodfortheQueue">back Back Method for the Queue</a></li><li><a href="global.html#createQueueCreationofQueueInstancewithpropercachingandOptionsformulator">createQueue Creation of Queue Instance with proper caching and Options formulator</a></li><li><a href="global.html#depReportDependenciesReportasStringfromthemiscUtils">depReport Dependencies Report as String from the misc Utils</a></li><li><a href="global.html#destroyDestroypacketandinternalworkingsofqueueregister/cachesandwithacompleteclearenceandevenclearbackendcachestoremoveallconnectionsfromeveryrequestorhandlersifany">destroy Destroy packet and internal workings of queue register/caches and with a complete clearence and even clear backend caches to remove all connections from every request or handlers </a></li><li><a href="global.html#destroyQueueDestroyQueuefromPlayerCachesanddestroyQueueinternallyifanyprocessarerunningoronwait">destroyQueue Destroy Queue from Player Caches and destroy Queue internally </a></li><li><a href="global.html#extractorDataManagerextractorDataManagerforthemanupualtingextractorDatafromtheTrack">extractorDataManager extractorDataManager for the manupualting extractorData from the Track</a></li><li><a href="global.html#getGetTracksDataortriggeringtrackeventforTracksMod">get Get Tracks Data or triggering track event for Tracks Mod</a></li><li><a href="global.html#getPlaydlPlay-dlextractorFunctionwithrepsecttointernalfunctionstosupportthecauseofusage">getPlaydl Play-dl extractor Function with repsect to internal functions to support the cause of usage</a></li><li><a href="global.html#getQueryFetchingTracksDataandPlaylistDataRequestfromextractorsusingdownloaderclass">getQuery Fetching Tracks Data and Playlist Data Request from extractors using downloader class</a></li><li><a href="global.html#getQueueFetching/GettingofQueueInstancewithpropercachingandOptionsformulator">getQueue Fetching/Getting of Queue Instance with proper caching and Options formulator</a></li><li><a href="global.html#getYoutubedlYoutube-dlextractorFunctionwithrepsecttointernalfunctionstosupportthecauseofusage">getYoutubedl Youtube-dl extractor Function with repsect to internal functions to support the cause of usage</a></li><li><a href="global.html#muteMutetheMusicPlayeroftheQueue">mute Mute the Music Player of the Queue</a></li><li><a href="global.html#pausePauseAudioPlayeroftheQueue">pause Pause Audio Player of the Queue</a></li><li><a href="global.html#playPlayMethodofQueueClasstoplayrawQueryInfoafterprocessingandfetchfromwebusingextractors">play Play Method of Queue Class to play raw Query Info after processing and fetch from web using extractors</a></li><li><a href="global.html#setVolumeSettingVolumeoftheAudioPlayer">setVolume Setting Volume of the Audio Player</a></li><li><a href="global.html#shuffleShuffleMethodfortheQueue">shuffle Shuffle Method for the Queue</a></li><li><a href="global.html#skipSkippingCurrentTracktospecifiedTrack-Countsorby-defaultonnextsong">skip Skipping Current Track to specified Track-Counts or by-default on next song</a></li><li><a href="global.html#stopStoppingCurrentTrackalongsidewithQueuetoacompletesilencewithcleaning">stop Stopping Current Track along side with Queue to a complete silence with cleaning</a></li><li><a href="global.html#unmuteUn-MutetheMusicPlayeroftheQueue">unmute Un-Mute the Music Player of the Queue</a></li><li><a href="global.html#unpauseUn-PauseAudioPlayeroftheQueue">unpause Un-Pause Audio Player of the Queue</a></li></ul>
</nav>

<div id="main">
    <div class="burger">
        <div class="burger-line-1"></div>
        <div class="burger-line-2"></div>
        <div class="burger-line-3"></div>
    </div>

    <h1 class="page-title">Source: gen/packets.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const {
  createAudioPlayer,
  createAudioResource,
  StreamType,
  entersState,
  AudioPlayerStatus,
  getVoiceConnection,
  AudioPlayer,
  AudioPlayerState,
} = require('@discordjs/voice');

const {
  Message,
  CommandInteraction,
  VoiceChannel,
  StageChannel,
} = require('discord.js');

const queue = require('../core/queue');
const downloader = require('./downloader');
const {
  Track,
  Playlist,
  Options,
  packetOptions,
  packetPrivateCaches,
} = require('../misc/enums');
const {
  voiceResolver,
  messageResolver,
  interactionResolver,
} = require('../utils/snowflakes');
const player = require('../core/player');
const eventEmitter = require('../utils/eventEmitter');
const voiceMod = require('../utils/voiceMod');
const {
  invalidRequiredSource,
  invalidVoiceChannel,
  invalidQuery,
} = require('../misc/errorEvents');

class packets {
  /**
   * @constructor
   * @param {queue} queue Actual Related or Source Queue Data for fetching sub-property infos
   * @param {packetOptions} options Options for backend stuffs
   */
  constructor(queue, options = packetOptions) {
    /**
     * Actual Related or Source Queue Data for fetching sub-property infos
     * @type {queue}
     * @readonly
     */
    this.queue = queue;

    /**
     * Discord Guild Id Data for checks of voiceState Updates
     * @type {string | number}
     * @readonly
     */
    this.guildId = queue?.guildId;

    /**
     * Cached Options for backend stuffs
     * @type {packetOptions}
     * @readonly
     */
    this.options = options;

    /**
     * Actual Player for event Emitter and other sub-propeties works
     * @type {player}
     * @readonly
     */
    this.player = queue?.player;

    /**
     * Actual Event Emitter for emitting events based on better events handling
     * @type {eventEmitter}
     * @readonly
     */
    this.eventEmitter = queue?.eventEmitter;

    /**
     * Actual Voice Channel Moderator on better voice Connections handling
     * @type {voiceMod}
     * @readonly
     */
    this.voiceMod = queue?.voiceMod;

    /**
     * Actual Audio Player for subscription and play Audio Resource
     * @type {AudioPlayer}
     * @readonly
     */
    this.audioPlayer = createAudioPlayer();

    /**
     * Array of Tracks and Stream-Data for backend tracks usage
     * @type {object[]}
     * @readonly
     */
    this.tracksMetadata = [];

    /**
     * Comprise of private caches and settings for rare used stuff or misc stuff
     * @type {packetPrivateCaches}
     * @readonly
     */
    this.__privateCaches = packetPrivateCaches;

    /**
     * Downloader Class Instance for extractors works and fetching of tracks from raw Query and other stuff
     * @type {downloader}
     * @readonly
     */
    this.downloader = new downloader(this, options?.downloaderOptions);

    this.audioPlayer.on(
      'stateChange',
      async (oldState, newState) => await this.__audioPlayerStateMod(oldState, newState),
    );
  }

  /**
   * @method getQuery Fetching Tracks Data and Playlist Data Request from extractors using downloader class
   * @param {string} rawQuery String Value for fetching/Parsing with the help of extractors
   * @param {string | number | VoiceChannel | StageChannel | Message} voiceSnowflake voice Channel Snowflake in terms of further resolving value using in-built resolvers to connect to play song on it
   * @param {string | number | Message | CommandInteraction } requestedSource requested By Source Data for checks and avoid the further edits on it by some stranger to protect the integrity
   * @param {packetOptions} options packets Options for further requirements
   * @returns {Promise&lt;Boolean | undefined>} Returns Extractor Data from the defalt extractors
   */

  async getQuery(
    rawQuery,
    voiceSnowflake,
    requestedSource,
    options = packetOptions,
  ) {
    try {
      if (this.destroyed) return undefined;
      else if (!(rawQuery &amp;&amp; typeof rawQuery === 'string' &amp;&amp; rawQuery !== ''))
        return undefined;
      if (
        options?.songQueryFilters &amp;&amp;
        !this.downloader.__queryFilter(rawQuery, options?.songQueryFilters)
      )
        throw invalidQuery();
      requestedSource =
        interactionResolver(this.player?.discordClient, requestedSource) ??
        (await messageResolver(this.player?.discordClient, requestedSource));
      if (
        !requestedSource ||
        (requestedSource &amp;&amp;
          (requestedSource?.user?.bot ||
            requestedSource?.author?.bot ||
            requestedSource?.member?.bot ||
            requestedSource?.member?.user?.bot))
      )
        throw new invalidRequiredSource();
      voiceSnowflake = await voiceResolver(
        this.queue?.discordClient,
        voiceSnowflake,
      );
      if (
        !voiceSnowflake ||
        (voiceSnowflake &amp;&amp; requestedSource?.guildId !== voiceSnowflake?.guildId)
      )
        throw new invalidVoiceChannel();
      this.eventEmitter.emitDebug(
        'voiceChannel Resolver',
        'Resolving Voice Snowflake Value for actual Voice Channel Data for Audio Player and Voice Connection',
        {
          voiceSnowflake,
        },
      );
      await this.voiceMod?.connect(voiceSnowflake, requestedSource);
      this.eventEmitter.emitDebug(
        'Downloader',
        'Making Request to default extractors for parsing and fetch required Track Data',
        {
          rawQuery,
          downloaderOptions: options?.downloaderOptions,
        },
      );
      return await this.downloader.get(
        rawQuery,
        requestedSource,
        options?.downloaderOptions,
      );
    } catch (errorMetadata) {
      this.eventEmitter.emitError(
        errorMetadata,
        ' - Provide Correct Query or Voice Channel for Connection and Audio Processing\n - Provide Correct Raw Query for Songs like Url or Simple Query from Supported Platforms\n - Provide Correct User Data on requested By Data for resolve and internals Matters',
        'packets.generate()',
        {
          rawQuery,
          voiceSnowflake,
          options,
        },
        options?.eventOptions,
      );
      return undefined;
    }
  }

  /**
   * @private
   * @method __audioPlayerStateMod Audio Player Status Update Event Handler for further decision makings on queue.tracks
   * @param {AudioPlayerState} oldState Audio Player State for checkinga and take further decisons of if and else
   * @param {AudioPlayerState} newState Audio Player State for checkinga and take further decisons of if and else
   * @returns {Promise&lt;Boolean | undefined>} Returns Boolean or undefined on failure or success rate!
   */

  async __audioPlayerStateMod(oldState, newState) {
    if (this.destroyed) return undefined;
    else if (newState?.status === AudioPlayerStatus.Idle) {
      this.eventEmitter.emitDebug(
        'AudioPlayerStatus Idle Status',
        'If Player went Idle on status Update event - changes required',
        {
          newState,
        },
      );
      this.eventEmitter.emitEvent(
        'trackEnd',
        'Previous Track has been Ended Now',
        {
          queue: this.queue,
          track: this.tracksMetadata?.[0]?.track,
          user: this.tracksMetadata?.[0]?.track?.user,
          remainingTracks: this.tracksMetadata?.slice(1) ?? [],
          requestedSource: this.tracksMetadata?.[0]?.track?.requestedSource,
        },
      );
      this.__cacheAndCleanTracks();
      if (this.tracksMetadata?.length > 0)
        return await this.__audioResourceMod();
      else if (this.tracksMetadata?.length === 0) {
        const lastTrack =
          this.__privateCaches?.completedTracksMetadata?.length > 1
            ? this.__privateCaches?.completedTracksMetadata?.[
              this.__privateCaches?.completedTracksMetadata?.length - 1
            ]
            : undefined;
        this.eventEmitter.emitEvent(
          'queueEnd',
          'Tracks Queue has been Ended with no Tracks left to play',
          {
            queue: this.queue,
            track: lastTrack,
            user: lastTrack?.user,
            previousTracks: this.__privateCaches?.completedTracksMetadata,
            requestedSource: lastTrack?.requestedSource,
          },
        );
        this.__privateCaches.completedTracksMetadata = [];
      }
      return undefined;
    } else return undefined;
  }

  /**
   * @method __cacheAndCleanTracks Cache and Clean Tracks on Track End event Trigger/Requirement
   * @param {object} trackOptions Track Cleaning Options with start and clean options , just like splice function arguments
   * @param {number | 1} preserveTracks Preserving Tracks in completedTracks Cache Data for further use like back or autoplay to avoid giving un-neccassay repeatitions
   * @returns {Boolean | undefined} Returns Boolean or undefined on failure or success rate!
   */
  __cacheAndCleanTracks(
    trackOptions = { startIndex: 0, cleanTracks: 1 },
    preserveTracks = 1,
  ) {
    if (this.destroyed) return undefined;
    else if (
      !this.tracksMetadata?.[0] ||
      trackOptions?.cleanTracks > this.tracksMetadata?.length
    )
      return undefined;
    this.eventEmitter.emitDebug(
      'Cleaning Track Request',
      'Cleaning Used/Processed Track for Audio Resource Mod to Process',
      {
        trackOptions,
      },
    );
    const leftOutTracks = this.tracksMetadata.splice(
      trackOptions?.startIndex,
      trackOptions?.cleanTracks,
    );
    if (!isNaN(Number(preserveTracks)) &amp;&amp; Number(preserveTracks) === 1)
      this.__privateCaches.completedTracksMetadata.push(
        leftOutTracks?.[0]?.track,
      );
    else if (!isNaN(Number(preserveTracks)) &amp;&amp; Number(preserveTracks) > 1)
      this.__privateCaches.completedTracksMetadata.push(
        leftOutTracks
          ?.slice(0, Number(preserveTracks))
          .map((ob) => ob?.track)
          ?.filter(Boolean),
      );
    else return undefined;
    return true;
  }

  /**
   * @private
   * @method __audioResourceMod Audio Resource Moderator for fetching and making of Audio Resource and play in on AudioPlayer and generate Player Subscription
   * @param {Track} rawTrackData Track Metadata consist of Track and Stream-Data to be precise for events and creation of audio resource
   * @returns {Promise&lt;Boolean | undefined>} Returns Boolean or undefined on failure or success rate!
   */

  async __audioResourceMod(rawTrackData = this.tracksMetadata?.[0]) {
    try {
      if (this.destroyed) return undefined;
      const streamData = rawTrackData?.streamData;
      if (!streamData) return undefined;
      this.eventEmitter.emitDebug(
        'Audio Resource',
        'new Audio Resource will be Created for Audio Player to Play',
        {
          streamData,
        },
      );
      rawTrackData.track.audioResource = createAudioResource(
        streamData?.stream?.buffer,
        {
          inputType: streamData?.type ?? StreamType.Arbitrary,
        },
      );
      this.audioPlayer.play(rawTrackData.track.audioResource);
      await entersState(this.audioPlayer, AudioPlayerStatus.Playing, 2e3);
      const voiceConnection = getVoiceConnection(this.guildId);
      this.eventEmitter.emitEvent(
        'trackStart',
        'Processed Track will be Played now within few seconds',
        {
          queue: this.queue,
          track: rawTrackData?.track,
          user: rawTrackData?.track?.user,
          requestedSource: rawTrackData?.track?.requestedSource,
        },
      );
      this.__privateCaches.audioPlayerSubscription = voiceConnection.subscribe(
        this.audioPlayer,
      );
      this.eventEmitter.emitDebug(
        'Subscription Created',
        'Player Susbcription has been Created and Discord Client started playing Songs in Voice Channel',
        {
          voiceConnection,
          streamData,
          queue: this.queue,
          packet: this,
        },
      );

      return true;
    } catch (errorMetadata) {
      this.eventEmitter.emitError(
        errorMetadata,
        undefined,
        {
          rawTrackData,
        },
        this.options?.eventOptions,
      );
      return undefined;
    }
  }

  /**
   * @method __trackMovementManager Track Movement Audio Resource and Fetching Properly
   * @param {Number | 1} trackIndex Tracks Count or Track index in the Tracks Cache
   * @param {String | "back"} movement Movement Direction of the Track
   * @return {Promise&lt;boolean> | boolean} Returns Success or Failure as per Boolean Value
   */
  async __trackMovementManager(trackIndex = 1, movement = 'back') {
    switch (movement?.toLowerCase()?.trim()) {
      case 'back':
        if (trackIndex >= this.__privateCaches?.completedTracksMetadata?.length)
          return undefined;
        const track =
          this.__privateCaches?.completedTracksMetadata?.[
            this.__privateCaches?.completedTracksMetadata?.length - trackIndex
          ];
        if (trackIndex === 1)
          this.__privateCaches?.completedTracksMetadata?.pop();
        if (!track) return undefined;
        const streamData = await track.__refresh(true);
        if (!streamData?.stream) return undefined;
        this.tracksMetadata?.splice(1, 0, {
          track,
          streamData,
        });
        this.audioPlayer.stop(true);
        break;
      default:
        return undefined;
    }
    return true;
  }

  /**
   * @method __playlistMod Playlist Moderator for events and parsing raw Playlist/Album Data
   * @param {object} playlist Playlist raw Data from extractors with tracks Data (if any)
   * @returns {Boolean} Returns Boolean or undefined on failure or success rate!
   */

  __playlistMod(playlist) {
    if (this.destroyed) return undefined;
    const parsedPlaylist = new Playlist(playlist);
    return this.eventEmitter.emitEvent(
      'playlistAdd',
      'Playlist has been recognised and related tracks will be slowly added to caches',
      {
        queue: this.queue,
        playlist: parsedPlaylist,
        user: parsedPlaylist?.user,
        requestedSource: parsedPlaylist?.requestedSource,
      },
    );
  }

  /**
   * @method __tracksMod Tracks Moderator for events and parsing raw Tracks Data from default extractors
   * @param {string} extractor Extractor Data's name for checking the source of the data
   * @param {Playlist} playlist Related Playlist Data from extractor
   * @param {Track} rawTrack Raw Track Data for Parsinga and fetched from extractors for audio Resource
   * @param {object} metadata Metadata Value to be repaired after getting operation object value
   * @returns {Promise&lt;Boolean | undefined>} Returns Boolean or undefined on failure or success rate!
   */

  async __tracksMod(extractor, playlist, rawTrack, metadata) {
    try {
      if (this.destroyed) return undefined;
      this.eventEmitter.emitDebug(
        'Tracks Modification',
        'Tracks and Streams will be Modified for Audio Player',
        {
          rawTrack,
          playlist: new Playlist(playlist),
          extractor,
          metadata,
        },
      );
      const track = new Track(rawTrack);
      const streamData = track?.__getStream(true);
      this.tracksMetadata.push({ track, streamData });
      if (!track.playlistId)
        this.eventEmitter.emitEvent(
          'trackAdd',
          'Tracks has been Added to Cache for Further Modification',
          {
            queue: this.queue,
            track,
            playlist: new Playlist(playlist),
            user: track?.user,
            tracks: this.queue?.tracks,
            requestedSource: track?.requestedSource,
          },
        );
      if (this.tracksMetadata?.length === 1) await this.__audioResourceMod();
      return true;
    } catch (errorMetadata) {
      this.eventEmitter.emitError(
        errorMetadata,
        undefined,
        {
          extractor,
          playlist,
          rawTrack,
          metadata,
        },
        this.options?.eventOptions,
      );
      return undefined;
    }
  }

  /**
   * @method __perfectClean Perfect clean for avoiding Memory leak and release the tide with RAM usuage
   * @returns {Boolean | true} Returns Boolean value as true
   */
  __perfectClean() {
    delete this.audioPlayer;
    delete this.downloader;
    delete this.__privateCaches;
    delete this.tracksMetadata;
    return true;
  }

  /**
   * @method extractorDataManager extractorDataManager for the manupualting extractorData from the Track
   * @param {Track} rawData Track Data for extractorDataManager or Playlist or Tracks
   * @param {String} status Status Value for switch case workign
   * @returns {Boolean} Returns failure for undefined or true on success
   */

  extractorDataManager(rawData, status = 'destroy') {
    if (!(status &amp;&amp; typeof status === 'string' &amp;&amp; status?.trim() !== ''))
      return undefined;
    switch (status?.toLowerCase()?.trim()) {
      case 'destroy':
        if (rawData?.rawTrack?.extractorData) return undefined;
        else rawData?.rawTrack?.extractorData?.destroy(true);
        break;
      case 'parseracks':
        if (
          !(
            rawData?.rawTracks &amp;&amp;
            Array.isArray(rawData?.rawTracks) &amp;&amp;
            rawData?.rawTracks?.length > 0
          )
        )
          return undefined;
        const parsedTracks = rawData?.rawTracks?.map((t) => new Track(t));
        this.eventEmitter.emitEvent(
          'tracksAdd',
          'Tracks has been Added to Queue Successfully',
          {
            queue,
            tracksCount: parsedTracks?.length,
            tracks: parsedTracks,
            playlist:
              rawData?.playlist ??
              parsedTracks?.find((t) => t &amp;&amp; t?.playlist)?.playlist,
            user: parsedTracks?.find((t) => t &amp;&amp; t?.user)?.user,
            requestedSource: parsedTracks?.find((t) => t &amp;&amp; t?.requestedSource)
              ?.requestedSource,
          },
        );
        break;
      default:
        return undefined;
    }
    return true;
  }

  /**
   * Boolean value related to queue.destroyed value
   * @type {Boolean | true}
   * @readonly
   */

  get destroyed() {
    return this.queue?.destroyed;
  }

  /**
   * Class Name for Type Value as "packet"
   * @type {string | "packet"}
   * @readonly
   */

  get type() {
    return 'packet';
  }
}

module.exports = packets;
</code></pre>
        </article>
    </section>





</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Sun Aug 21 2022 06:25:20 GMT+0000 (Coordinated Universal Time) using <a href="https://github.com/zyrouge/jsdoc-skyceil">Skyceil Theme</a>
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>

</body>
</html>
